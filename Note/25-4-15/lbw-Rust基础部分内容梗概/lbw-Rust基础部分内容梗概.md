Rust

#### 更新Rust

-rustup update

#### 卸载Rust

-rustup self uninstall

#### 安装验证

rustc --version

#### 打开本地文档

> ~~rustup doc~~
>
> **错误，不知道为啥我的电脑不行，根据deepseek修复也没用**
>
> **更新为**
>
> `rustup doc --path`
>
> `start 'path'`
>
> *手动打开*

#### 开发工具

vscode

-安装rust插件

#### 编译与运行rust程序

##### 编译：

`rustc main.rs`

<!--只适用于小程序-->

##### 运行：

-windows:`.\main.exe`

-linux/mac:`./main`

##### main函数

<!--每个rust可执行程序最先运行的程序-->

##### 打印文本：

`println!("hello,world!");`

<!--rust的缩进是4个空格而不是tab-->

<!--println!是一个Rust macro(宏)，如果是函数的话就没有"!"-->

#### Rust

rust是预先编译的语言，可以先编译程序，然后吧可执行文件交给别人运行，无需安装rust;

#### Cargo

##### 使用cargo创建项目

`cargo new hello_cargo`

##### cargo.toml

<!--toml格式，是cargo的配置模式-->

##### [package]

<!--是一个区域标题，表示下方内容是用来配置包的-->

##### [dependencies]

<!--另一个区域的开始，他会列出项目的依赖项-->

在Rust中，代码的包称作crate

##### 构建Cargo项目

###### cargo bulid

--创建可执行文件：

--运行可执行文件

第一次运行cargo bulid 会在顶层目录生成cargo.lock文件

###### cargo run

编译并运行cargo项目

###### cargo check

检查代码，确保能通过编译，但是不产生可执行文件

#### 变量与可变性

-声明变量使用了let关键字

-默认情况下，变量是不可变的（lmmutable）

#### 变量与常量（constant）

##### 常量与不可变的变量有很多区别

-不可以使用mut，常量永远都是不可变的；

-声明常量必须使用const,他的类型必须被标注

-常量可以在任何作用域中进行声明，包括全局作用域

-常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值；

#### shadowing

-可以使用相同的名字声明新的变量，新的变量就会shadow(隐藏)之前声明的同名变量

-使用let声明的同名新变量，也是不可变的

-使用let声明的同名新变量，它的类型可以与之前不同

#### 数据类型

-标量和复合类型

-Rust是静态编译语言，在编译时必须知道所有变量的类型

-------基于使用的值，编译器通常能够推断出他的具体类型

--------但如果可能的类型比较多（eg:String->整数的parse()),就必须添加类型标注，否则编译会报错

##### 标量类型

-一个标量的类型代表一个单个的值

###### ---整数类型

<img src="images\image-20250325161456696.png" alt="image-20250325161456696" style="zoom:67%;" />

isize和usize类型

- 位数由程序运行的计算机的架构所决定，如果是64位计算机，那就是64位

- 主要使用场景是对某种集合进行索引操作



###### ---整数字面值

<img src="images\image-20250325162035520.png" alt="image-20250325162035520" style="zoom:67%;" />

- 除了byte类型外，所有的数值字面值都允许使用类型后缀
  - eg :57u8 表示值为57，类型为u8

###### 整数溢出

eg:u8的范围是0-255，如果把一个u8变量的值设为256，那么

- 调试模式下编译：Rust会检查整数溢出，如果发生溢出，程序在运行时就会panic

- 发布模式下（-release）编译：Rust不会检查可能导致panic的整数溢出

  - 如果发生溢出：Rust会执行“环绕”操作

    - 256变成0，257变成1

      但程序不会panic

###### ---浮点类型

- f32,32位，单精度

- f64,64位，双精度，默认类型

  

###### ---布尔类型

- ture/false
- 占用一个字节
- bool

###### ---字符类型

- char类型，描述语言中最基础的单个字符
- 使用单引号
- 占用4个字节
- 是unicode标量值，可以表示 拼音、中日韩文、零长度空白字符、emoji表情
  - U+0000->U+D7FF
  - U+E000->U+10FFFF

##### 复合类型

- Tuple(元组)

  - 可以将多个类型的多个值放在一个类型中
  - 长度固定，一旦声明就无法改变
  - 可以使用模式匹配来解构一个Tuple来获取元素的值

  ![image-20250325223013761](images\image-20250325223013761.png)

​		![image-20250325223232106](images\image-20250325223232106.png)

数组

- 长度是固定的

- 当你想让你的数组存放在stack上而不是heap(堆)，或想保持由固定数量的元素，这时使用数组

- 数组没有vector灵活

  - vector长度可以改变

- 数组的类型

  - [类型；长度]

  - eg:`let a:[i32;5]=[1,2,3,4,5];`

- ​	另一种声明数组的方法
  - 如果数组中每个元素值都相同
    - [指定初始值；数组的长度]
    - eg:`let a = [3;5];相当于let a = [3,3,3,3,3];`
- 访问数组的元素
  - 如果访问的索引超出了数组的范围，那么
    - 编译会通过
    - 运行会报错
      - Rust不会允许其继续访问相应地址的内存

##### 函数

- 使用fn关键字
- 命名规范，所有字母都小写，单词之间使用下划线分开
- 语句不返回值，不可以使用let 将一个语句赋给一个变量
- 在->符号后边声明函数返回值的类型，但不可以为返回值命名
- 在Rust中，返回值是函数体里面最后一个表达式的值

##### 控制流

- ![image-20250325225614683](images\image-20250325225614683.png)

##### Rust的循环

- loop

![image-20250325231111608](images\image-20250325231111608.png)

- while

- for

  ![image-20250325231506528](images\image-20250325231506528.png)

###### range

![image-20250325231631095](images\image-20250325231631095.png)

![image-20250325231658387](images\image-20250325231658387.png)

##### 所有权

- Rust的核心特性就是所有权
- 所有程序在运行时都必须管理他们使用计算机内存的方式
  - 有些语言有垃圾回收机制
  - 有些语言，程序员必须显式的分配和释放内存
- Rust采用第三种方式
  - 内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则
  - 当程序运行时，所有权特性不会减慢程序的运行速度

##### stack vs heap

- 所有存储在Stack上的数据必须拥有已知的固定的大小
  - 编译时大小未知的数据或运行时大小可能发生变化的数据必须存放在heap上
- heap内存组织性差一些
  - 当你把数据放入heap时，你会请求一定数量的空间
  - 操作系统在heap中找到一块足够大的空间，把他标记为在用，并返回一个指针，也就是这个空间的地址
  - 这个过程叫做在heap上进行分配
- 把值压入栈不叫分配
- 指针是已知固定大小的，可以把指针存放在栈中
- 把数据压入栈中要比在heap上分配快得多
  - 因为操作系统不需要寻找用来存储新数据的空间，那个位置永远在stack的顶端
- 在heap上分配要做更多的工作：
  - 操作系统首先要找到一个足够大的空间来存放数据，然后做好记录方便下次分配
- 访问速度：stack>heap
- 所有权存在的原因
  - 管理heap数据
    - 跟踪代码的的哪些部分正在使用heap的哪些数据
    - 最小化heap上的最小数据量
    - 清理heap上未使用的数据以避免空间不足

##### 所有权规则

- 每个值都有一个变量，这个变量是该值的所有者
- 每个值同时只能有一个所有者
- 当所有者超出作用域（scope）时，该值将被删除

##### String类型

- Rust还有第二种字符串类型：String

  - 在heap上分配，能够存储在编译时未知数量的文本

- 创建String类型的值

  - 可以使用from函数从字符串字面值创建String类型
  - eg: `let s = String::from("hello");`
  - 这类的字符串是可以被修改的

- 为什么String类型的值可以修改，而字符串面值却不能修改？

  - 因为它们处理内存的方式不同

- 内存和分配

  - 字符串字面值，在编译时就知道他的内容了，其文本内容直接被编码到最终的可执行文件中
    - 速度快、高效是因为其不可变性
  - String类型，为了支持可变性，需要在heap上分配内存来保存编译时未知的文本内容：
    - 操作系统必须在运行时来请求内存
      - 这步通过调用String::from来实现
    - 当用完String后，需要使用某种方式将内存返回给操作系统
      - ![image-20250326180338639](images\image-20250326180338639.png)
      - **Rust采用了不同的方式：**
      - **当拥有他的变量走出作用范围时，内存会立即自动的交还给操作系统**
      - **drop函数**

- 变量与数据交互的方式：移动（Move）

  - 多个变量可以与同一个数据使用一种独特的方式来交互

  - ![image-20250326181006048](images\image-20250326181006048.png)
  - ![image-20250326181037520](images\image-20250326181037520.png)
  - 发生了质的移动，s1失效，无法使用
  - ![image-20250326181155327](images\image-20250326181155327.png)
  - ![image-20250326181234071](images\image-20250326181234071.png)
  - ![image-20250326181258801](images\image-20250326181258801.png)
  - ![image-20250326181326994](images\image-20250326181326994.png)
  - ![image-20250326181340458](images\image-20250326181340458.png)
  - ![image-20250326181509620](images\image-20250326181509620.png)
  - ![image-20250326181618157](images\image-20250326181618157.png)

##### 所有权与函数

- ![image-20250326181715669](images\image-20250326181715669.png)
  - ![image-20250326181738549](images\image-20250326181738549.png)

##### 返回值与作用域

- ![image-20250326181949941](images\image-20250326181949941.png)
  - ![image-20250326182010698](images\image-20250326182010698.png)
- ![image-20250326182205244](images\image-20250326182205244.png)
- ![image-20250326182226659](images\image-20250326182226659.png)
  - ![image-20250326182242353](images\image-20250326182242353.png)
  - ![image-20250326182348962](images\image-20250326182348962.png)
    - ![image-20250326182420638](images\image-20250326182420638.png)

##### 引用和借用

- ![image-20250326182518290](images\image-20250326182518290.png)
- ![image-20250326182532887](images\image-20250326182532887.png)
- 借用
  - ![image-20250326182701277](images\image-20250326182701277.png)
  - ![image-20250326182734625](images\image-20250326182734625.png)
  - 不可以通过借用的东西（s）修改其执行的数据（s1）;
  - 和变量一样，引用默认也是不可变的
  - **可变引用**
    - ![image-20250326183219770](images\image-20250326183219770.png)
      - ![image-20250326183257140](images\image-20250326183257140.png)
    - ![image-20250326183329193](images\image-20250326183329193.png)
    - ![image-20250326183401177](images\image-20250326183401177.png)
      - ![image-20250326183424307](images\image-20250326183424307.png)
    - ![image-20250326183457411](images\image-20250326183457411.png)
      - ![image-20250326183522873](images\image-20250326183522873.png)
      - ![image-20250326183535018](images\image-20250326183535018.png)
- ![image-20250326183615754](images\image-20250326183615754.png)
  - ![image-20250326183636629](images\image-20250326183636629.png)
  - ![image-20250326183705074](images\image-20250326183705074.png)
    - ![image-20250326183733496](images\image-20250326183733496.png)
    - ![image-20250326183745325](images\image-20250326183745325.png)
- ![image-20250326183851935](images\image-20250326183851935.png)

##### 切片

- ![image-20250326183936954](images\image-20250326183936954.png)
- 字符串切片
  - ![image-20250326185938797](images\image-20250326185938797.png)
  - ![image-20250326190013803](images\image-20250326190013803.png)
  - ![image-20250326190212422](images\image-20250326190212422.png)
  - ![image-20250326190243224](images\image-20250326190243224.png)
  - ![image-20250326190408251](images\image-20250326190408251.png)
- ![image-20250326190443442](images\image-20250326190443442.png)

##### 字符串字面值是切片

- ![image-20250326192332757](images\image-20250326192332757.png)
- ![image-20250326192507114](images\image-20250326192507114.png)

##### 将字符串切片作为参数传递

- ![image-20250326192612929](images\image-20250326192612929.png)
- ![image-20250326192632072](images\image-20250326192632072.png)
  - ![image-20250326192704492](images\image-20250326192704492.png)
- ![image-20250326192728023](images\image-20250326192728023.png)
- ![image-20250326192743082](images\image-20250326192743082.png)
- 其他类型的切片
  - ![image-20250326192903115](images\image-20250326192903115.png)



##### struct

- 定义并实例化struct
  - ![image-20250327150826270](C:\Users\伯瓦尔\AppData\Roaming\Typora\typora-user-images\image-20250327150826270.png)
  - ![image-20250327150844927](images\image-20250327150844927.png)
  - ![image-20250327150923604](images\image-20250327150923604.png)
- 取得struct里面某个值
  - ![image-20250327151044000](images\image-20250327151044000.png)
- 注意
  - ![image-20250327151200122](images\image-20250327151200122.png)
  - ![image-20250327151222916](images\image-20250327151222916.png)
  - ![image-20250327151304538](images\image-20250327151304538.png)
- struct更新语法
  - ![image-20250327151458394](images\image-20250327151458394.png)
- tuple struct
  - ![image-20250327151609820](images\image-20250327151609820.png)
  - ![image-20250327151657609](images\image-20250327151657609.png)
- Unit-Like struct (没有任何字段)
  - ![image-20250327151748529](images\image-20250327151748529.png)
  - ![image-20250327151819359](images\image-20250327151819359.png)
- struct 数据的所有权
  - ![image-20250327151850991](images\image-20250327151850991.png)
  - ![image-20250327151919333](images\image-20250327151919333.png)
  - ![image-20250327152000276](images\image-20250327152000276.png)
    - ![image-20250327152021790](images\image-20250327152021790.png)
    - ![image-20250327152044360](images\image-20250327152044360.png)



![image-20250327152631148](images\image-20250327152631148.png)

##### struct的方法

- ![image-20250327155324773](images\image-20250327155324773.png)
- ![image-20250327155548666](images\image-20250327155548666.png)
- ![image-20250327155706992](images\image-20250327155706992.png)
- 方法调用的运算符
  - ![image-20250327155906903](images\image-20250327155906903.png)
- 关联函数
  - ![image-20250327160102004](images\image-20250327160102004.png)
  - ![image-20250327160125023](images\image-20250327160125023.png)
  - ![image-20250327160215931](images\image-20250327160215931.png)
- 多个impl块
  - struct可以有多个impl块



##### 枚举与模式匹配

- 定义枚举

  - ![image-20250327161150703](images\image-20250327161150703.png)

- 枚举值

  - ![image-20250327161217425](images\image-20250327161217425.png)
  - ![image-20250327161310070](images\image-20250327161310070.png)

- 将数据附加到枚举的变体中

  - ![image-20250327161424016](images\image-20250327161424016.png)
  - ![image-20250327161450188](images\image-20250327161450188.png)
  - ![image-20250327161502730](images\image-20250327161502730.png)
  - ![image-20250327161539182](images\image-20250327161539182.png)

- ![image-20250327161609538](images\image-20250327161609538.png)

- ![image-20250327161631165](images\image-20250327161631165.png)

- 为枚举定义方法

  - 与struct类似

  - ![image-20250327161730459](images\image-20250327161730459.png)

##### option枚举

- ![image-20250327161907118](images\image-20250327161907118.png)

- Rust没有NULL

  - ![image-20250327162000804](images\image-20250327162000804.png)

- Rust中类似NULL概念的枚举-Option<T>

  - ![image-20250327162120425](images\image-20250327162120425.png)
  - ![image-20250327162134243](images\image-20250327162134243.png)
  - ![image-20250327162151653](images\image-20250327162151653.png)

- ![image-20250327162240244](images\image-20250327162240244.png)

  - ![image-20250327162342876](images\image-20250327162342876.png)

  - ![image-20250327162300719](images\image-20250327162300719.png)

##### 强大的控制流运算符-match

- ![image-20250327232157185](images\image-20250327232157185.png)
- ![image-20250327232256809](images\image-20250327232256809.png)
- ![image-20250327232310531](images\image-20250327232310531.png)

##### 绑定值的模式

- ![image-20250327232534914](images\image-20250327232534914.png)
- ![image-20250327232706692](images\image-20250327232706692.png)
- 匹配Option<T>
  - ![image-20250327232802601](images\image-20250327232802601.png)
- match匹配必须穷举所有的可能

- ![image-20250327233105610](images\image-20250327233105610.png)
- ![image-20250327233125375](images\image-20250327233125375.png)

##### if let,简单的控制流

- ![image-20250327233230173](images\image-20250327233230173.png)
- ![image-20250327233302757](images\image-20250327233302757.png)
- if let else
  - ![image-20250327233354992](images\image-20250327233354992.png)



##### package,Crate,Module

- 模块系统

  - ![image-20250327233609855](images\image-20250327233609855.png)

- Package和Crate

  - Crate的类型

    - binary
    - libary

  - Crate Root

    - ![image-20250327233727392](images\image-20250327233727392.png)

  - 一个Package

    - ![image-20250327233837028](images\image-20250327233837028.png)
    - ![image-20250327233854333](images\image-20250327233854333.png)
    - ![image-20250327233908051](images\image-20250327233908051.png)

    - ![image-20250327234144442](images\image-20250327234144442.png)
    - ![image-20250327234348047](images\image-20250327234348047.png)

- ![image-20250327234427827](images\image-20250327234427827.png)
- ![image-20250327234514485](images\image-20250327234514485.png)
- ![image-20250327234530222](images\image-20250327234530222.png)
- ![image-20250327234611265](images\image-20250327234611265.png)
- ![image-20250327234709838](images\image-20250327234709838.png)

##### 路径（Path）

- ![image-20250327234806838](images\image-20250327234806838.png)
- ![image-20250327234946135](images\image-20250327234946135.png)
- ![image-20250327235055666](images\image-20250327235055666.png)
- ![image-20250327235143370](images\image-20250327235143370.png)
- ![image-20250327235206664](images\image-20250327235206664.png)
- ![image-20250327235245603](images\image-20250327235245603.png)
- ![image-20250327235423943](images\image-20250327235423943.png)
- ![image-20250327235458503](images\image-20250327235458503.png)
- ![image-20250327235524272](images\image-20250327235524272.png)
  - ![image-20250327235553544](images\image-20250327235553544.png)
  - ![image-20250327235613472](images\image-20250327235613472.png)
- ![image-20250327235859129](images\image-20250327235859129.png)

##### use关键字

- ![image-20250328083257029](images\image-20250328083257029.png)
- ![image-20250328083310157](images\image-20250328083310157.png)
- ![image-20250328083515484](images\image-20250328083515484.png)
  - ![image-20250328083557399](images\image-20250328083557399.png)
- ![image-20250328083627640](images\image-20250328083627640.png)
- ![image-20250328083813885](images\image-20250328083813885.png)
  - ![image-20250328083854205](images\image-20250328083854205.png)
- ![image-20250328083937869](images\image-20250328083937869.png)
- ![image-20250328084125002](images\image-20250328084125002.png)
- ![image-20250328084316163](images\image-20250328084316163.png)
  - ![image-20250328084332035](images\image-20250328084332035.png)
- ![image-20250328084405182](images\image-20250328084405182.png)
  - ![image-20250328084432039](images\image-20250328084432039.png)
  - ![image-20250328084449426](images\image-20250328084449426.png)



##### 命令行

- cargo build
  - ![image-20250328084608563](images\image-20250328084608563.png)
  - ![image-20250328084632818](images\image-20250328084632818.png)
  - ![image-20250328084708176](images\image-20250328084708176.png)
  - ![image-20250328084806647](images\image-20250328084806647.png)
  - ![image-20250328084824361](images\image-20250328084824361.png)



##### 将模块拆分为不同的文件

- ![image-20250328085107437](images\image-20250328085107437.png)
- ![image-20250328085200986](images\image-20250328085200986.png)
- ![image-20250328085255937](images\image-20250328085255937.png)



##### 常用的集合

- Vector
  - **![image-20250328085416961](images\image-20250328085416961.png)**
  - ![image-20250328085448088](images\image-20250328085448088.png)
  - ![image-20250328085515415](images\image-20250328085515415.png)
  - ![image-20250328085618617](images\image-20250328085618617.png)
  - ![image-20250328085646953](images\image-20250328085646953.png)
  - ![image-20250328085751962](images\image-20250328085751962.png)
  - ![image-20250328085853443](images\image-20250328085853443.png)
  - ![image-20250328085931632](images\image-20250328085931632.png)
  - ![image-20250328090004008](images\image-20250328090004008.png)
  - ![image-20250328090151275](images\image-20250328090151275.png)
  - ![image-20250328090342052](images\image-20250328090342052.png)
  - ![image-20250328090403324](images\image-20250328090403324.png)
  - ![image-20250328090439492](images\image-20250328090439492.png)
  - ![image-20250328090459748](images\image-20250328090459748.png)

![image-20250328090556280](images\image-20250328090556280.png)

- ![image-20250328090628869](images\image-20250328090628869.png)



##### String

- ![image-20250328090834524](images\image-20250328090834524.png)
- ![image-20250328090859777](images\image-20250328090859777.png)
- ![image-20250328090948268](images\image-20250328090948268.png)
- ![image-20250328091023524](images\image-20250328091023524.png)
- ![image-20250328091111703](images\image-20250328091111703.png)
- ![image-20250328091148274](images\image-20250328091148274.png)
- ![image-20250328091210352](images\image-20250328091210352.png)
- ![image-20250328091228696](images\image-20250328091228696.png)
- ![image-20250328091302624](images\image-20250328091302624.png)
- ![image-20250328091406596](images\image-20250328091406596.png)
- ![image-20250328091436255](images\image-20250328091436255.png)
- ![image-20250328091513554](images\image-20250328091513554.png)
- ![image-20250328091529226](images\image-20250328091529226.png)
- ![image-20250328091653926](images\image-20250328091653926.png)
- ![image-20250328091711538](images\image-20250328091711538.png)
- ![image-20250328091754078](images\image-20250328091754078.png)
- ![image-20250328091943916](images\image-20250328091943916.png)
- ![image-20250328092032910](images\image-20250328092032910.png)
- format!不会取得任何参数的所有权
- format!与println!类似，但不是将字符串打印，而是返回一个字符串
- `String s = format!("{}-{}-{}",s1,s2,s3);`
- rust String不支持按索引的形式进行访问
  - ![image-20250329160317628](images\image-20250329160317628.png)
- ![image-20250329160348869](images\image-20250329160348869.png)
- ![image-20250329160543016](images\image-20250329160543016.png)
- ![image-20250329160717315](images\image-20250329160717315.png)
- ![image-20250329160806654](images\image-20250329160806654.png)
- ![image-20250329160833391](images\image-20250329160833391.png)



##### hashmap

- ![image-20250329160911084](images\image-20250329160911084.png)
- ![image-20250329160919769](images\image-20250329160919769.png)
- ![image-20250329160957069](images\image-20250329160957069.png)
- ![image-20250329161118501](images\image-20250329161118501.png)
- ![image-20250329161206335](images\image-20250329161206335.png)
- ![image-20250329161320176](images\image-20250329161320176.png)
- ![image-20250329161410181](images\image-20250329161410181.png)
- ![image-20250329161459759](images\image-20250329161459759.png)
- ![image-20250329161522295](images\image-20250329161522295.png)
- ![image-20250329161700214](images\image-20250329161700214.png)
- ![image-20250329161714886](images\image-20250329161714886.png)
- ![image-20250329161800500](images\image-20250329161800500.png)
- ![image-20250329161842118](images\image-20250329161842118.png)
- ![image-20250329161911845](images\image-20250329161911845.png)
- ![image-20250329162003045](images\image-20250329162003045.png)
- ![image-20250329162015496](images\image-20250329162015496.png)
- ![image-20250329162144474](images\image-20250329162144474.png)



##### 错误处理

- ![image-20250329162508601](images\image-20250329162508601.png)
- ![image-20250329162555823](images\image-20250329162555823.png)
- ![image-20250329162802396](images\image-20250329162802396.png)
- ![image-20250329162834922](images\image-20250329162834922.png)
- panic!(宏)的例子
  - ![image-20250331134154134](images\image-20250331134154134.png)
- ![image-20250331134359338](images\image-20250331134359338.png)
- 设置环境变量RUST_BACKTRACE可得到回溯信息

##### Result枚举与可恢复的错误

![image-20250331134655793](images\image-20250331134655793.png)

![image-20250331134758158](images\image-20250331134758158.png)

![image-20250331134902739](images\image-20250331134902739.png)

匹配不同的错误

![image-20250331135040182](images\image-20250331135040182.png)

![image-20250331135101396](images\image-20250331135101396.png)

![image-20250331135127847](images\image-20250331135127847.png)

unwrap

- match表达式的一个快捷方法
- 如果Result的结果是Ok,返回Ok里面的值
- 如果Result结果是Err,调用panic!宏

expect

- 和unwrap类似，但可指定错误信息
- ![image-20250331135544993](images\image-20250331135544993.png)

传播错误

- ![image-20250331135656419](images\image-20250331135656419.png)

？运算符

- 传播错误的一种快捷方式
- ![image-20250331140310025](images\image-20250331140310025.png)
- ![image-20250331140420480](images\image-20250331140420480.png)
- ![image-20250331140527893](images\image-20250331140527893.png)
- ？运算符只能用于返回Result的函数或Option<>
- ![image-20250331140705293](images\image-20250331140705293.png)
- ![image-20250331140815245](images\image-20250331140815245.png)

- ![image-20250331141008545](images\image-20250331141008545.png)
- ![image-20250331141053346](images\image-20250331141053346.png)
- ![image-20250331141141210](images\image-20250331141141210.png)
- ![image-20250331141212210](images\image-20250331141212210.png)



##### 泛型、trait\生命周期

- 提取函数消除重复

- 泛型
  - ![image-20250331141851762](images\image-20250331141851762.png)
  - ![image-20250331141954515](images\image-20250331141954515.png)
  - ![image-20250331142228444](images\image-20250331142228444.png)
  - ![image-20250331142253463](images\image-20250331142253463.png)
  - ![image-20250331142415407](images\image-20250331142415407.png)
  - ![image-20250331142517598](images\image-20250331142517598.png)
  - ![image-20250331142646915](images\image-20250331142646915.png)
  - struct里的泛型类型参数可以和方法的泛型类型参数不同
  - ![image-20250331142803877](images\image-20250331142803877.png)
- trait
  - ![image-20250331142958006](images\image-20250331142958006.png)
  - ![image-20250331143039073](images\image-20250331143039073.png)
  - ![image-20250331143151859](images\image-20250331143151859.png)
  - ![image-20250331143502528](images\image-20250331143502528.png)
  - ![image-20250331143630072](images\image-20250331143630072.png)
  - 无法从方法的重写实现中调用默认的实现
- Trait作为参数
  - ![image-20250331152633883](images\image-20250331152633883.png)
  - ![image-20250331152657798](images\image-20250331152657798.png)
  - ![image-20250331152722563](images\image-20250331152722563.png)
  - ![image-20250331152839032](images\image-20250331152839032.png)
  - ![image-20250331152901855](images\image-20250331152901855.png)
  - ![image-20250331152959884](images\image-20250331152959884.png)
  - trait bound使用where子句
    - ![image-20250331153154266](images\image-20250331153154266.png)
    - 在方法签名后边指定where子句
- 实现trait作为返回类型
  - ![image-20250331153509370](images\image-20250331153509370.png)
  - impl trait只能返回确定类型的同一种类型，返回可能不同类型的代码会报错
- 使用trait Bound有条件的实现方法
  - ![image-20250331154040803](images\image-20250331154040803.png)
  - ![image-20250331154145203](C:\Users\伯瓦尔\AppData\Roaming\Typora\typora-user-images\image-20250331154145203.png)



##### 生命周期

- Rust的每个引用都有自己的生命周期
- 生命周期：引用保持有效的作用域
- 大多数情况下：生命周期是隐式的。可被推断的。
- 当引用的生命周期可能以不同的方式关联时，就需要手动标注生命周期
- ![image-20250331154524249](images\image-20250331154524249.png)

###### 借用检查器

- ![image-20250331154714741](images\image-20250331154714741.png)

###### 函数中的泛型生命周期

- ![image-20250331154909138](images\image-20250331154909138.png)

###### 生命周期的标注语法

- 生命周期的标注不会改变引用的生命周期长度
- 当指定了泛型生命周期参数，函数可以接收带有任何生命周期的引用
- 生命周期的标注：描述了多个引用的生命周期的关系，但不影响生命周期

###### 语法

- ![image-20250331155342775](images\image-20250331155342775.png)
- ![image-20250331155359589](images\image-20250331155359589.png)
- ![image-20250331155505886](images\image-20250331155505886.png)
- 单个生命周期标注本身没有意义

###### 函数签名中的生命周期

- ![image-20250331155616928](images\image-20250331155616928.png)
- ![image-20250331155633690](images\image-20250331155633690.png)

###### 深入理解生命周期

- 指定生命周期参数的方式依赖于函数所做的事情
- ![image-20250331160234519](images\image-20250331160234519.png)
- 只有引用有生命周期问题

###### struct定义中的生命周期标注

- ![image-20250331160427733](images\image-20250331160427733.png)
- ![image-20250331160452851](images\image-20250331160452851.png)

###### 生命周期的省略

- ![image-20250331160838700](images\image-20250331160838700.png)

###### 输入、输出生命周期

- ![image-20250331160913407](images\image-20250331160913407.png)

###### 生命周期省略的三个规则

- ![image-20250331161027406](images\image-20250331161027406.png)

###### 方法定义中的生命周期标注

- ![image-20250331161834592](images\image-20250331161834592.png)
- ![image-20250331162253048](images\image-20250331162253048.png)
- ![image-20250331162317225](images\image-20250331162317225.png)



![image-20250331192223729](images\image-20250331192223729.png)

![image-20250331192406756](images\image-20250331192406756.png)



![image-20250331192443920](images\image-20250331192443920.png)

![image-20250331192535336](images\image-20250331192535336.png)

  ![image-20250331193618129](images\image-20250331193618129.png)

![image-20250331193928697](images\image-20250331193928697.png)

![image-20250331194204123](images\image-20250331194204123.png)

![image-20250331194335882](images\image-20250331194335882.png)

![image-20250331194415700](images\image-20250331194415700.png)

![image-20250331194639319](images\image-20250331194639319.png)

![image-20250331194726430](images\image-20250331194726430.png)

![image-20250331194906683](images\image-20250331194906683.png)

![image-20250331195348584](images\image-20250331195348584.png)

![image-20250331195424544](images\image-20250331195424544.png)

![image-20250331195511387](images\image-20250331195511387.png)

- 如果想在成功的测试中看到打印的内容： --show-output



##### 按名称运行测试

- ![image-20250331195757966](images\image-20250331195757966.png)

###### 忽略测试

- ![image-20250331195905883](images\image-20250331195905883.png)
- ![image-20250331195920299](images\image-20250331195920299.png)
- 单独运行被标记的测试
  - cargo test -- --ignored



##### 测试的组织

测试的分类

- 单元测试，小专注；一次对一个模块进行隔离的测试；可测试private接口
- 集成测试：在库外部，和其他外部代码一样使用你的代码；只能使用public接口；可能在每个测试中使用到多个模块；
- ![image-20250331200600921](images\image-20250331200600921.png)

- ![image-20250331200732989](images\image-20250331200732989.png)
- ![image-20250331200933611](images\image-20250331200933611.png)
- tests目录与src目录并列
- ![image-20250331201101142](images\image-20250331201101142.png)
- ![image-20250331201402664](images\image-20250331201402664.png)
- 在tests中创建一个新的目录，将要共享的文件放在该目录下
- eg:common中的文件作为共享的文件，在进行cargo test时不进行编译
- ![image-20250331201638599](images\image-20250331201638599.png)





##### 项目实例：命令行程序

- ![image-20250331220515402](images\image-20250331220515402.png)
- ![image-20250331221933098](images\image-20250331221933098.png)
- ![image-20250331225130845](images\image-20250331225130845.png)
- ![image-20250401155612020](images\image-20250401155612020.png)



辨析：String &String  str &str 

match具体流程



![image-20250403135700753](images\image-20250403135700753.png)



##### 闭包

- ![image-20250403140406355](images\image-20250403140406355.png)
- 闭包的类型推断
  - ![image-20250403152547667](images\image-20250403152547667.png)
- 函数和闭包的定义语法
  - ![image-20250403152615807](images\image-20250403152615807.png)
  - 闭包的定义最终只会为参数/返回值推断出唯一具体的类型
- 使用泛型参数和fn Trait 来存储闭包
  - ![image-20250403153002430](images\image-20250403153002430.png)
  - ![image-20250403153045738](images\image-20250403153045738.png)
  - 所以需要使用：泛型和trait Bound
  - ![image-20250403153151302](images\image-20250403153151302.png)
  - ![image-20250403153655046](images\image-20250403153655046.png)
- 使用闭包捕获环境
  - ![image-20250403153849763](images\image-20250403153849763.png)
  - ![image-20250403154037734](images\image-20250403154037734.png)
- ![image-20250403154119382](images\image-20250403154119382.png)
- ![image-20250403154154094](images\image-20250403154154094.png)
  - 使用move关键字是的 x 的所有权 移动到了闭包里
- ![image-20250403154329131](images\image-20250403154329131.png)



##### 迭代器

- ![image-20250403154423094](images\image-20250403154423094.png)
- iterator trait
  - ![image-20250403154549190](images\image-20250403154549190.png)
  - 实现iterator trait 需要你定义一个 item类型，它用于next方法的返回类型（迭代器的返回类型)
  - ![image-20250403154753005](images\image-20250403154753005.png)
  - ![image-20250403154926020](images\image-20250403154926020.png)
- 消耗迭代器的方法
  - ![image-20250403155030197](images\image-20250403155030197.png)
  - ![image-20250403155055067](images\image-20250403155055067.png)
  - ![image-20250403155158119](images\image-20250403155158119.png)
  - collect方法，消耗性适配器，把结果收集到一个集合类型中
- 使用闭包捕获环境、通过迭代器
  - ![image-20250403155439893](images\image-20250403155439893.png)
  - ![image-20250403155608107](images\image-20250403155608107.png)
- 使用iterator trait 来创建自定义迭代器
  - 实现next方法
  - ![image-20250403160117620](images\image-20250403160117620.png)
- 循环与迭代器的性能
  - 零开销抽象
  - ![image-20250403162336493](images\image-20250403162336493.png)



##### cargo , crates.io

- ![image-20250403162526996](images\image-20250403162526996.png)
- 通过release profile 来自定义构建
  - ![image-20250405132532915](images\image-20250405132532915.png)
  - ![image-20250405132632275](images\image-20250405132632275.png)
  - ![image-20250405132802246](images\image-20250405132802246.png)
  - ![image-20250405132835365](images\image-20250405132835365.png)
  - ![image-20250405132922764](images\image-20250405132922764.png)
  - ![image-20250405133005913](images\image-20250405133005913.png)
  - ![image-20250405133054203](images\image-20250405133054203.png)
  - ![image-20250405133146347](images\image-20250405133146347.png)
  - ![image-20250405133240915](images\image-20250405133240915.png)
  - ![image-20250405133617734](images\image-20250405133617734.png)



##### 智能指针

- ![image-20250405135220012](images\image-20250405135220012.png)
- ![image-20250405135246192](images\image-20250405135246192.png)
- ![image-20250405135312605](images\image-20250405135312605.png)
- ![image-20250405135338073](images\image-20250405135338073.png)
- ![image-20250405135408215](images\image-20250405135408215.png)
- ![image-20250405135441695](images\image-20250405135441695.png)
- ![image-20250405135520079](images\image-20250405135520079.png)



##### Box<T>

- ![image-20250405135618648](images\image-20250405135618648.png)
- ![image-20250405135716349](images\image-20250405135716349.png)
- ![image-20250405135855071](images\image-20250405135855071.png)
- ![image-20250405140018871](images\image-20250405140018871.png)
- ![image-20250405140035554](images\image-20250405140035554.png)
- ![image-20250405140302660](images\image-20250405140302660.png)
- ![image-20250405140328457](images\image-20250405140328457.png)
- ![image-20250405140420539](images\image-20250405140420539.png)
- 常规引用是一种指针，可以把Box<T>当作引用来看
  - ![image-20250405140714781](images\image-20250405140714781.png)
- ![image-20250405140744498](images\image-20250405140744498.png)
- ![image-20250405140856390](images\image-20250405140856390.png)
- ![image-20250405141117530](images\image-20250405141117530.png)
- ![image-20250405141319983](images\image-20250405141319983.png)



##### Drop trait

- ![image-20250405141408229](images\image-20250405141408229.png)
- ![image-20250405141556094](images\image-20250405141556094.png)
- ![image-20250405141642706](images\image-20250405141642706.png)



##### Rc<T>引用计数智能指针

- ![image-20250405141911480](images\image-20250405141911480.png)
- ![image-20250405141950152](images\image-20250405141950152.png)
- ![image-20250405142039578](images\image-20250405142039578.png)
- ![image-20250405142329133](images\image-20250405142329133.png)
- ![image-20250405142448084](images\image-20250405142448084.png)
- ![image-20250405142529044](images\image-20250405142529044.png)



##### RefCell<T>和内部可变性

- ![image-20250405153737065](images\image-20250405153737065.png)
- 借用规则
  - 在任何给定的时间里，你要么只能拥有一个可变引用要么只能拥有任意数量的不可变引用
  - 引用总是有效的
- ![image-20250405153946957](images\image-20250405153946957.png)
- ![image-20250405154048760](images\image-20250405154048760.png)
- ![image-20250405154142769](images\image-20250405154142769.png)
- ![image-20250405154158877](images\image-20250405154158877.png)
- ![image-20250405154236838](images\image-20250405154236838.png)
- 使用RefCell<T>在运行时记录借用信息
  - ![image-20250405155612805](images\image-20250405155612805.png)
  - ![image-20250405155703818](images\image-20250405155703818.png)
  - ![image-20250405155718376](images\image-20250405155718376.png)
- 其他和实现内部可变形的数据：
  - ![image-20250405155933539](images\image-20250405155933539.png)

##### 循环引用可导致内存泄漏

- ![image-20250405160044091](images\image-20250405160044091.png)
- ![image-20250405160533358](images\image-20250405160533358.png)
- ![image-20250405160627023](images\image-20250405160627023.png)



##### 无畏并发

- ![image-20250405161012010](images\image-20250405161012010.png)
- ![image-20250405161058448](images\image-20250405161058448.png)
- ![image-20250405161128716](images\image-20250405161128716.png)
- ![image-20250405161241572](images\image-20250405161241572.png)
- ![image-20250405162835763](images\image-20250405162835763.png)
- ![image-20250405163019074](images\image-20250405163019074.png)
- ![image-20250405163128558](images\image-20250405163128558.png)
- ![image-20250405163343979](images\image-20250405163343979.png)
- ![image-20250405163422912](images\image-20250405163422912.png)
- ![image-20250405163600700](images\image-20250405163600700.png)
- ![image-20250405163642964](images\image-20250405163642964.png)
- ![image-20250405163726241](images\image-20250405163726241.png)
- ![image-20250405163742141](images\image-20250405163742141.png)
- ![image-20250405163829460](images\image-20250405163829460.png)
- ![image-20250405163943339](images\image-20250405163943339.png)
- ![image-20250405164025135](images\image-20250405164025135.png)
- ![image-20250405164046693](images\image-20250405164046693.png)
- ![image-20250405164121623](images\image-20250405164121623.png)
- ![image-20250405164210133](images\image-20250405164210133.png)
- 多线程共享Mutex
  - ![image-20250405164554831](images\image-20250405164554831.png)
  - ![image-20250405164729047](images\image-20250405164729047.png)
- ![image-20250405164805353](images\image-20250405164805353.png)
- ![image-20250405164840549](images\image-20250405164840549.png)
- ![image-20250405164918842](images\image-20250405164918842.png)
- ![image-20250405164941646](images\image-20250405164941646.png)



##### Rust的面向对象编程特性

- ![image-20250405165057517](images\image-20250405165057517.png)
- ![image-20250405165155191](images\image-20250405165155191.png)
- ![image-20250405175556433](images\image-20250405175556433.png)
- ![image-20250405180110679](images\image-20250405180110679.png)
- ![image-20250405180144262](images\image-20250405180144262.png)
- ![image-20250405180242130](images\image-20250405180242130.png)
- ![image-20250405181958092](images\image-20250405181958092.png)
- ![image-20250405182026616](images\image-20250405182026616.png)
- ![image-20250405182237033](images\image-20250405182237033.png)



##### 模式匹配

- ![image-20250405182320969](images\image-20250405182320969.png)
- ![image-20250405182340630](images\image-20250405182340630.png)
- ![image-20250405182417064](images\image-20250405182417064.png)
- ![image-20250405182604795](images\image-20250405182604795.png)
- ![image-20250405182645993](images\image-20250405182645993.png)
- ![image-20250405182757257](images\image-20250405182757257.png)
- ![image-20250405182829954](images\image-20250405182829954.png)
- ![image-20250405182905184](images\image-20250405182905184.png)
- ![image-20250405182940147](images\image-20250405182940147.png)

##### 可辩驳性：模式是否会无法匹配

- ![image-20250405183132327](images\image-20250405183132327.png)



##### 模式语法

- ![image-20250405183328814](images\image-20250405183328814.png)
- ![image-20250405183338135](images\image-20250405183338135.png)
- ![image-20250405183441679](images\image-20250405183441679.png)
- ![image-20250405183455001](images\image-20250405183455001.png)
- ![image-20250405183514521](images\image-20250405183514521.png)
- ![image-20250405183535862](images\image-20250405183535862.png)
- ![image-20250405183605631](images\image-20250405183605631.png)
- ![image-20250405183638186](images\image-20250405183638186.png)
- 解构枚举：
  - ![image-20250405183733949](images\image-20250405183733949.png)
- ![image-20250405183839404](images\image-20250405183839404.png)
- ![image-20250405183932155](images\image-20250405183932155.png)
- ![image-20250405184015859](images\image-20250405184015859.png)
- ![image-20250405184040726](images\image-20250405184040726.png)
- ![image-20250405184050248](images\image-20250405184050248.png)
- ![image-20250405184108218](images\image-20250405184108218.png)
- ![image-20250405184120540](images\image-20250405184120540.png)
- ![image-20250405184159695](images\image-20250405184159695.png)
- ![image-20250405184236280](images\image-20250405184236280.png)
- ![image-20250405184311159](images\image-20250405184311159.png)
- 使用下划线不会产生绑定操作，所有权未移动
- ![image-20250405184353010](images\image-20250405184353010.png)
- ![image-20250405184418479](images\image-20250405184418479.png)
- ![image-20250405184458285](images\image-20250405184458285.png)
- ![image-20250405184521962](images\image-20250405184521962.png)
- ![image-20250405184616537](images\image-20250405184616537.png)
- ![image-20250405184652230](images\image-20250405184652230.png)



##### 高级特性

- 不安全Rust
  - ![image-20250405184855348](images\image-20250405184855348.png)
  - ![image-20250405184947961](images\image-20250405184947961.png)
  - ![image-20250405185114792](images\image-20250405185114792.png)
  - 可以在不安全代码块外创建原始指针。但必须在不安全代码块内对原始指针进行解引用
  - ![image-20250405185328850](images\image-20250405185328850.png)
  - ![image-20250405185410424](images\image-20250405185410424.png)
  - ![image-20250405185456959](images\image-20250405185456959.png)
  - ![image-20250405185539951](images\image-20250405185539951.png)
  - ![image-20250405185807480](images\image-20250405185807480.png)
  - 任何在extern中声明的函数都是不安全的
  - ![image-20250405185934394](images\image-20250405185934394.png)
  - ![image-20250405190018795](images\image-20250405190018795.png)
  - ![image-20250405190054777](images\image-20250405190054777.png)
  - ![image-20250405190318532](images\image-20250405190318532.png)
  - ![image-20250405190337760](images\image-20250405190337760.png)
  - ![image-20250405190514273](images\image-20250405190514273.png)
  - ![image-20250405190539507](images\image-20250405190539507.png)
  - ![image-20250405190617600](images\image-20250405190617600.png)
- 在Trait定义中使用关联类型来指定占位类型
  - ![image-20250405190745261](images\image-20250405190745261.png)
  - ![image-20250405190813883](images\image-20250405190813883.png)
  - ![image-20250405191052996](images\image-20250405191052996.png)
  - ![image-20250405191121696](images\image-20250405191121696.png)
  - 在实现体内部声明关联类型
  - ![image-20250405191218048](images\image-20250405191218048.png)
  - ![image-20250405191322557](images\image-20250405191322557.png)
  - ![image-20250405191403953](images\image-20250405191403953.png)
  -  ![image-20250405191431160](images\image-20250405191431160.png)
  - ![image-20250405191608448](images\image-20250405191608448.png)
  - 调用结构体本身的方法以及它实现的trait的方法（一个结构体容易区分）
  - ![image-20250405191849876](images\image-20250405191849876.png)
  - 当多个结构体实现重名方法时，不易区分时
  - ![image-20250405191948672](images\image-20250405191948672.png)
  - ![image-20250405192035831](images\image-20250405192035831.png)
  - ![image-20250405192107440](images\image-20250405192107440.png)
  - ：冒号后边是他所依赖的Trait
  - ![image-20250405192323558](images\image-20250405192323558.png)
- 高级类型
  - ![image-20250405201825717](images\image-20250405201825717.png)
  - ![image-20250405202030166](images\image-20250405202030166.png)
  - ![image-20250405202542034](images\image-20250405202542034.png)
  - ![image-20250405203605376](images\image-20250405203605376.png)
  - ![image-20250405203633403](images\image-20250405203633403.png)
  - ![image-20250405203657843](images\image-20250405203657843.png)
  - ![image-20250405203726917](images\image-20250405203726917.png)
  - ![image-20250405203815396](images\image-20250405203815396.png)
- 高级函数和闭包
  - ![image-20250405204031168](images\image-20250405204031168.png)
  - ![image-20250405204213780](images\image-20250405204213780.png)
  - ![image-20250405204345891](images\image-20250405204345891.png)
- 宏
  - ![image-20250405204509777](images\image-20250405204509777.png)
  - ![image-20250405204543880](images\image-20250405204543880.png)
  - ![image-20250405204622939](images\image-20250405204622939.png)
  - ![image-20250405204825604](images\image-20250405204825604.png)











